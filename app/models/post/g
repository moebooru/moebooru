require "download"

# These are methods dealing with getting the image and generating the thumbnail.
# It works in conjunction with the image_store methods. Since these methods have 
# to be called in a specific order, they've been bundled into one module.
module PostFileMethods
  def self.included(m)
    m.before_validation_on_create :download_source
    m.before_validation_on_create :determine_content_type
    m.before_validation_on_create :validate_content_type
    m.before_validation_on_create :generate_hash
    m.before_validation_on_create :set_image_dimensions
    m.before_validation_on_create :generate_sample
    m.before_validation_on_create :generate_preview
    m.before_validation_on_create :move_file
  end
  
  def validate_content_type
    if file_ext.empty?
      errors.add_to_base("No file received")
      return false
    end

    unless %w(jpg png gif swf).include?(file_ext.downcase)
      errors.add(:file, "is an invalid content type: " + file_ext.downcase)
      return false
    end
  end
  
  def file_name
    md5 + "." + file_ext
  end

  def delete_tempfile
    FileUtils.rm_f(tempfile_path)
    FileUtils.rm_f(tempfile_preview_path)
    FileUtils.rm_f(tempfile_sample_path)
  end

  def tempfile_path
    "#{RAILS_ROOT}/public/data/#{$PROCESS_ID}.upload"
  end

  def tempfile_preview_path
    "#{RAILS_ROOT}/public/data/#{$PROCESS_ID}-preview.jpg"
  end

  def file_size
    File.size(file_path) rescue 0
  end

  # Generate an MD5 hash for the file.
  def generate_hash
    unless File.exists?(tempfile_path)
      errors.add(:file, "not found")
      return false
    end

    self.md5 = File.open(tempfile_path, 'rb') {|fp| Digest::MD5.hexdigest(fp.read)}

    if Post.exists?(["md5 = ?", md5])
      delete_tempfile
      errors.add "md5", "already exists"
      return false
    else
      return true
    end
  end

  def generate_preview
    return true unless image? && width && height

    unless File.exists?(tempfile_path)
      errors.add(:file, "not found")
      return false
    end

    size = Danbooru.reduce_to({:width=>width, :height=>height}, {:width=>150, :height=>150})

    # Generate the preview from the new sample if we have one to save CPU, otherwise from the image.
    if File.exists?(tempfile_sample_path)
      path, ext = tempfile_sample_path, "jpg"
    else
      path, ext = tempfile_path, file_ext
    end

    begin
      Danbooru.resize(ext, path, tempfile_preview_path, size, 95)
    rescue Exception => x
      errors.add "preview", "couldn't be generated (#{x})"
      return false
    end

    return true
  end

  # Automatically download from the source if it's a URL.
  def download_source
    return if source !~ /^http:\/\// || !file_ext.blank?

    begin
      Download.download(:url => source) do |res|
        File.open(tempfile_path, 'wb') do |out|
          res.read_body do |block|
            out.write(block)
          end
        end
      end

      if self.source.to_s =~ /^http/
        self.source = "Image board"
      end

      return true
    rescue SocketError, URI::Error, SystemCallError => x
      delete_tempfile
      errors.add "source", "couldn't be opened: #{x}"
      return false
    end
  end

  def determine_content_type
    if not File.exists?(tempfile_path)
      errors.add_to_base("No file received")
      return false
    end

    imgsize = ImageSize.new(File.open(tempfile_path, 'rb'))
    if !imgsize.get_width.nil?
      self.file_ext = imgsize.get_type.gsub(/JPEG/, "JPG").downcase
    end
  end

  # Assigns a CGI file to the post. This writes the file to disk and generates a unique file name.
  def file=(f)
    return if f.nil? || f.size == 0
a = File.new("/tmp/templog", "a+")

    if f.local_path
      # Large files are stored in the temp directory, so instead of
      # reading/rewriting through Ruby, just rely on system calls to
      # copy the file to danbooru's directory.

a.write("%s to %s\n" % f.local_path, tempfile_path)
      FileUtils.cp(f.local_path, tempfile_path)
    else

a.write("... to %s\n" % tempfile_path)

      File.open(tempfile_path, 'wb') {|nf| nf.write(f.read)}
    end

a.close

  end

  def set_image_dimensions
    if image? or flash?
      imgsize = ImageSize.new(File.open(tempfile_path, "rb"))
      self.width = imgsize.get_width
      self.height = imgsize.get_height
    end
  end

  # Returns true if the post is an image format that GD can handle.
  def image?
    %w(jpg jpeg gif png).include?(file_ext.downcase)
  end

  # Returns true if the post is a Flash movie.
  def flash?
    file_ext == "swf"
  end

  def find_ext(file_path)
    ext = File.extname(file_path)
    if ext.blank?
      return "txt"
    else
      ext = ext[1..-1].downcase
      ext = "jpg" if ext == "jpeg"
      return ext
    end
  end

  def content_type_to_file_ext(content_type)
    case content_type.chomp
    when "image/jpeg"
      return "jpg"

    when "image/gif"
      return "gif"

    when "image/png"
      return "png"

    when "application/x-shockwave-flash"
      return "swf"

    else
      nil
    end
  end
  
  def preview_dimensions
    if image? && !is_deleted?
      dim = Danbooru.reduce_to({:width => width, :height => height}, {:width => 150, :height => 150})
      return [dim[:width], dim[:height]]
    else
      return [150, 150]
    end
  end
  
  def tempfile_sample_path
    "#{RAILS_ROOT}/public/data/#{$PROCESS_ID}-sample.jpg"
  end

  def regenerate_sample
    return false unless image?

    if generate_sample && File.exists?(tempfile_sample_path)
      FileUtils.mkdir_p(File.dirname(sample_path), :mode => 0775)
      FileUtils.mv(tempfile_sample_path, sample_path)
      FileUtils.chmod(0775, sample_path)
      return true
    else
      return false
    end
  end

  def generate_sample
    return true unless image?
    return true unless CONFIG["image_samples"]
    return true unless (width && height)
    return true if (file_ext.downcase == "gif")

    size = Danbooru.reduce_to({:width => width, :height => height}, {:width => CONFIG["sample_width"], :height => CONFIG["sample_height"]}, CONFIG["sample_ratio"])

    # We can generate the sample image during upload or offline.  Use tempfile_path
    # if it exists, otherwise use file_path.
    path = tempfile_path
    path = file_path unless File.exists?(path)
    unless File.exists?(path)
      errors.add(:file, "not found")
      return false
    end

    # If we're not reducing the resolution for the sample image, only reencode if the
    # source image is above the reencode threshold.  Anything smaller won't be reduced
    # enough by the reencode to bother, so don't reencode it and save disk space.
    if size[:width] == width && size[:height] == height &&
      File.size?(path) < CONFIG["sample_always_generate_size"]
      return true
    end

    # If we already have a sample image, and the parameters havn't changed,
    # don't regenerate it.
    if size[:width] == sample_width && size[:height] == sample_height
      return true
    end

    size = Danbooru.reduce_to({:width => width, :height => height}, {:width => CONFIG["sample_width"], :height => CONFIG["sample_height"]})
    begin
      Danbooru.resize(file_ext, path, tempfile_sample_path, size, 95)
    rescue Exception => x
      errors.add "sample", "couldn't be created: #{x}"
      return false
    end

    self.sample_width = size[:width]
    self.sample_height = size[:height]
    return true
  end

  # Returns true if the post has a sample image.
  def has_sample?
    sample_width.is_a?(Integer)
  end

  # Returns true if the post has a sample image, and we're going to use it.
  def use_sample?(user = nil)
    if user && !user.show_samples?
      false
    else
      CONFIG["image_samples"] && has_sample?
    end
  end

  def sample_url(user = nil)
    if status != "deleted" && use_sample?(user)
      store_sample_url
    else
      file_url
    end
  end

  def get_sample_width(user = nil)
    if use_sample?(user)
      sample_width
    else
      width
    end
  end

  def get_sample_height(user = nil)
    if use_sample?(user)
      sample_height
    else
      height
    end
  end
end
